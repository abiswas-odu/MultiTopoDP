<html>
    <head>
       <title>Diary in Old Dominion University</title>
  <style   type="text/css">   
  <!--   
  a:link   {   
  text-decoration:   none;   
  }   
  a:visited   {   
  text-decoration:   none;   
  }   
  a:hover   {   
  text-decoration:   underline;   
  }
  body      {color: purple;
  }   
  -->   
  </style>
    </head>
<body background = "../../images/sky.gif" link = burlywood vlink = purple>
	<li>Read Input
	<ul>
		<li>DFCDDirectory("./other", mode) <font color = gray>//Create <font color = red>./other</font> folder to save the results</font></li>
		<li>Read parameter <font color = gray>//read "parameter" file</font>
		<ul>
			<li>sequenceFile <font color = gray>//sequence file name, this file includes SSE index</font></li>
			<li>helixFile <font color = gray>//helical stick points file name, this file includes the stick points for each helix, this parameter is optional, if there is no helical stick points, use "-----" to represent</font></li>
			<li>sheetFile <font color = gray>//strand stick points file name, this file includes the stick points for each strand, this parameter is optional, if there is no strand stick points, use "------", to represent</font></li>
			<li>mrcFile <font color = gray>//skeleton file name, this file is generated by Gorgon</font></li>
			<li>K <font color = gray>//K value, program will generate top K topologies, if total topology number is less than K, generate the real number of topologies</font></li>
		</ul>
		</li>
	</ul>
	</li>
	<li>Read sequence information
	<ul>
		<li>readSequence() <font color = gray>//read SSE index information</font>
		<ul>
			<li>#include "Ultility.h" <font color = gray>//function in Ultility.h file</font></li>
			<li>class SequenceNode <font color = gray>//include the start index and end index of SSE, secondary structure type and index, index start from 0, this node current only consider one pair index, more options can be added later if needed, thus container is defined</font>
			<ul>
				<li>#include "SequenceNode.h" <font color = gray>//define SequenceNode class</font></li>
			</ul>
			</li>
		</ul>
		</li>
		<li>showSequence() <font color = gray>//show sequence information</font></li>
	</ul>
	</li>
	<li>Read sticks points
	<ul>
		<li>readStick() <font color = gray>//read helical stick points information and strand stick points information, these stick points are generated by Stone</font>
		<ul>
			<li>#include "Ultility.h"</li>
			<li>class StickNode <font color = gray>//include the stick points coordinates, secondary structure type, index and direction, index start from 0, direction is defined as 1 if stick points order is same as sequence order, -1 if vice verse</font></li>
		</ul>
		</li>
		<li>showSticks() <font color = gray>//show stick points information</font></li>
		<li>stickNodeContainer[i].pdb() <font color = gray>//save each stick by pdb format under <font color = red>"./other" folder, name as "Stick"+type+index+".pdb"</font></font></li>
	</ul>
	</li>
	<li><font color = gray>This algorithm requires N &gt; M, N is the number of SSE and M is the number of sticks, this is based on the reality that sticks always have miss</font></li>
	<li>Read skeleton information
	<ul>
		<li>#include "MRC.h" <font color = gray>//operations to mrc file</font></li>
		<li><a href = "http://ami.scripps.edu/prtl_data/mrc_specification.htm">MRC file format</a></li>
		<li>mrc.read() <font color = gray>//read skeleton file</font></li>
		<li>mrc.pdb() <font color = gray>//save skeleton points as pdb format to <font color = red>"./other/density.pdb"</font> file</font></li>
	</ul>
	</li>
	<li>Read true topology
	<ul>
		<li>getTrueTopology();//<font color = blue>read true topology from "./other/trueTopology"</font></li>
	</ul>
	</li>
	<li>Graph building
	<ul>
		<li>#include "Graph.h" <font color = gray>//includes the operations of graph</font>
		<ul>
			<li>class GraphNode <font color = gray>//row, column, rowIndex, columnIndex, type, inner, outer, weightIn, weightOut, record container, inner and outer are inner node and outer node, weightIn and weightOut are corresponding weight, record container is the table in Kamal's algorithm</font></li>
			<li>two dimensional array to save the graph</li>
		</ul>
		</li>
		<li><font color = gray>There are three build functions, each one is for different purpose</font></li>
		<li>graph.build(string, const vector&lt;SequenceNode&gt; &, const vector&lt;StickNode&gt; &) <font color = gray>//create the graph with Kamal's TopoDP_May2012's output, "./input/weightList.txt", which include source node, dest node, weight, start trace index, end trace index</font>
		<ul>
			<li>Kamal's graph includes start node and end node, thus the sequence index start from 1</li>
			<li>weight includes the loop trace information</li>
			<li>Trace Information
			<ul>
				<li>In order to use Kamal's information, several file are generated by TopoDP_May2012 program</li>
				<li>clique.txt, each line includes all the points in each clique, each three numbers represent the x, y, z of each point</li>
				<li>cliqueCenter.txt, each line represents a center of the clique</li>
				<li>tracePath.txt, each represents a trace, the number represents the index of central point in cliqueCenter.txt file, which start at 0</li>
				<li>weightList.txt, firstNode secondNode weight traceFirst traceSecond</li>
				<li>traceLength.txt, trace length (angstrom nAA)</li>
			</ul>
			</li>
			<li>allocate nodes for graph <font color = gray>//initialize graph</font></li>
			<li>read weight from "weightList.txt and update node</li>
			<li>showGraph() <font color = gray>//show graph in <font color = red>"./other/graph.txt"</font>, use kwrite open it to make sure that line lenght has no limit, which includes source node, dest node and corresponding weight, index start from 0</font></li>
		</ul>
		</li>
		<li>graph.build(const vector&lt;SequenceNode&gt; &, const vector&lt;StickNode&gt; &) <font color = gray>//build graph by naive difference between sequence length and stick side-point distance</font>
		<ul>
			<li>allocate node for graph <font color = gray>//if the length between sequence and stick are over 60%, set this node as "N", which means this node does not exist</font></li>
			<li>showNode() <font color = gray>//generate node information to <font color = red>"./other/node.txt"</font></font></li>
			<li>get diff value <font color = gray>//N-M, N is number of sequence node, M is number of stick node without considering direction</font></li>
			<li>set weight <font color = gray>//set weight if the sequence length greater than the stick length</font></li>
			<li>showGraph() <font color = gray>//output graph information to <font color = red>"./other/graph.txt"</font></font></li>
		</ul>
		</li>
		<li>graph.buildUpdate(const MRC &, const vector&lt;SequenceNode&gt; &, const vector&lt;StickNode&gt; &) <font color = gray>//build graph by considering the loop alongs skeleton voxel trace, not finish yet ...</font>
		<ul>
			<li>mrc.getPoints() <font color = gray>//get density points</font></li>
			<li>readParameter() <font color = gray>//read parameter from "./parameterGraph", which will be used to removed the points around helical sticks and strand sticks</font></li>
			<li>delete points around stick <font color = gray>//in order to avoid the disturb of the point around SSE, remove the points around it, first build a cylinder by the start point, end point, and radii, then delete points within the cylinder</font></li>
			<li>savePoint(voxelContainerDelete, "./other/densityDelete.pdb") <font color = gray>//save the density point after deleting with pdb format to <font color = red>"./other/densityDelete.pdb"</font></font></li>
			<li>peakCluster() <font color = gray>//cluster the left density points, save the central points into <font color = red>"./other/clusterCenter.pdb"</font></font></li>
			<li><font color = blue>//announce variable cDist, save the distance between centroid and centroid of clusters</font></li>
			<li><font color = blue>//announce adjMtrx, clx and clxAdjMtrx to save the adjancy list</font></li>
			<li>buildAdjMtrx(); <font color = blue>//Update cDist and adjMtrx, Kamal's program saved the central point of each cluster into the correspoinding cluster as last point, in Graph program, central point are independent, the buildAdjMtrx() was modified to calculate central point for each cluster by calling getClusterCenter()</font></li>
			<li>findallCliques(); <font color = blue>//re-organize clusters to cliques, combine close clusters into one clique</font></li>
			<li>saveClusterCenter(); <font color = blue>//save clique central point into <font color = red>"./other/cliqueCenter.pdb"</font></font></li>
			<li><font color = blue>Add the side points of each sticks into clique container, in which each clique only container one point</font></li>
			<li>saveClusterCenter(); <font color = blue>//save clique central points into <font color = red>"./other/points.pdb"</font> after add side points of the sticks into the cliques container</font></li>
			<li><font color = blue>Re-size the distance matrix cDist</font></li>
			<li>buildAdjMtrx(); <font color = blue>//update cDist and clxAdjMtrx, which are clique central distance matrix and clique adjacency matrix respectively</font></li>
			<li><font color = blue>Calculate clique centers and save them into container and clear clique container</font></li>
			<li>findTracePaths(); <font color = blue>//find all the trace paths</font></li>
			<li><font color = blue>Delete the empty traces, some traces from previous function only has the side point, which is not helpful to calculate weight</font></li>
			<li>outputTracePaths(); <font color = blue>//output the trace paths into ./other/Trace folder, index trace to <font color = red>"./other/Trace/index.txt"</font>, which include trace index, trace points index and the trace length, each trace path is saved to <font color = red>"./other/Trace/Trace*.pdb"</font> with pdb format</font></li>
			<li><font color = blue>Read the gap value</font></li>
			<li><font color = blue>Set up weight between nodes</font></li>
			<li><font color = blue>Get the cluster index of the start node and end node</font></li>
			<li>getBestFitting();<font color = blue>//get the best fitting path, check the path path between start node and end node, find the best fitting one, return the best weight and the trace index pair</font></li>
			<li><font color = blue>Output the weight information to <font color = red>"./other/weightDebug.txt"</font> which includes start node, endnode, real weight, ideal length and original weight, if the edge is in the true topology, "TruePath" is attached to the end</font></li>
		</ul>
		</li>
	</ul>
	</li>
	<li>graph.table() <font color = gray>//update table information by the edge and weight</font></li>
	<li>graph.trace() <font color = gray>//trace the minimum path</font>
	<ul>
		<li>there may have several minimum paths</li>
		<li>get the mininum records</li>
		<li>traceBack() <font color = gray>//get the path for corresponding minimum record</font></li>
		<li>showPath() <font color = gray>//reverse the order and output on terminal</font></li>
	</ul>
	</li>
	<li>graph.topK() <font color = gray>//get top K minimum traces</font>
	<ul>
		<li>output the top K topologies on terminal</li>
		<li>return a container which saves the top K path</li>
	</ul>
	</li>
	<li>saveTopology();<font color = blue>//save top K topologies into <font color = red>"./other/rank.txt"</font>, the rank of true topology is shown on the top</font></li>
	<li>graph.savePath();<font color = blue>//save trace path in folder <font color = red>"./other/TopologyPath"</font></font></li>
</body>
</html>
